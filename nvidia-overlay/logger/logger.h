#pragma once
#include <cstdint>
#include <stdio.h>
#include <Windows.h>
#include "../utils/e_status.h"


#define L_ERROR(txt) logger::error("%s(): %s", __FUNCTION__, txt); return utils::e_status::status_failed; // определние функции, какой то деф еррор который возвращает
#define L_ASSERT(cond, txt) if (!cond) { L_ERROR(txt); } // определенеи функции, аналогично только чтото с ассертом, тут есть аргументы конд то есть условие и текст. Если условие будет ложным, то будет выводится ошибка и текст
#define TRACE_FN logger::debug( "%s()", __FUNCTION__ ); // тут дефайнится какой то дебаг логгер, не совсем понятно что это

#define CREATE_LOGGER_METHOD(n) inline void n(const char* fmt, ...) { char buf[1024]; va_list va; va_start( va, fmt ); _vsnprintf_s( buf, 1024, fmt, va ); va_end( va ); log( #n, e_level_color::level_color_ ##n, buf ); }
// дефайнится функция креат логгер метод, который воид и принимает аргумент ссылку на строку и дальше ещё аргументы пошли, в теле функции создается массиа чар из 1024 символов,
// потом ва лист это хуета которая использутеся когда неопределенное количество аргументов в функции принимает аргументы, ва старт начинает передавать аргументы, потом вснпринтф записывает эти все выходные данные в списке аргументов, а ва енд заканчивает эту хуету и указательн ставит на нулл, аа вот лог хз что это, походу логгер который определен 

namespace logger { // задайтеся неймспейс логгера
	enum class e_level_color : uint32_t { // перечисление связанное с каким то цветом возможно как раз таки цветами логов энум класс имеет определенное место работы
		level_color_none = 15, // black bg and white fg
		level_color_debug = 8, // цвет для дебажной инфы
		level_color_info = 10, // цвет инфао
		level_color_warn = 14, // цвет варна
		level_color_error = 12 // цвет ошибки
	};

	namespace _colors { // неймспейс внутри логгера, уже калоррос
		extern void* m_console_handle; // экстернал обьявление уже иниц функции или пременной консоль хендла

		bool ensure_handle( ); // обьявление функции энсур хендл, находится в файле срр логгера
		void apply( uint32_t clr ); // обьясвленеи функции эплай, находится в срр логгера, даёт цвет текста в консоли
		void reset( ); // также находится в в срр логера, там все это есть ресетить цвет консоли
	}

	void log( const char* prefix, e_level_color level, const char* message ); // обьявление лог функции, которая также есть в срр логгера

#ifdef LOG_DEBUG_MESSAGES // если есть определение то будет следующее, это диреактива условной компиляции, которая будет выполняться при определенных условиях
	CREATE_LOGGER_METHOD( debug ); // какой то там логгер метод с передачей дебага
#else // иначе
	inline void debug( const char* fmt, ... ) { } // если же нет определения, то задаётся функция дебага, который принимает разное количество аругментов, но первое это указатель на конст, строку
#endif // заканчивается деф иф

	CREATE_LOGGER_METHOD( info ); // создается логгер метод инфо
	CREATE_LOGGER_METHOD( warn ); // создается логгер метод варн
	CREATE_LOGGER_METHOD( error ); // создается логгер метод ошибки
}

#undef CREATE_LOGGER_METHOD // обратно дефу, удаляет дефы
