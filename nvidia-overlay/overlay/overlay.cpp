#include "overlay.h"


namespace overlay { // пространство имён оверлея
	utils::e_status init( ) { // определение функции в пространстве утилка инита
		TRACE_FN; // тут также происходит логгирование трейс фн

		vars::m_window_hwnd = FindWindowW( L"CEF-OSC-WIDGET", L"NVIDIA GeForce Overlay" ); // функция поиска окна с названием нвидии оверлея, записывает в хендл переменную виндов хвнд
		L_ASSERT( vars::m_window_hwnd, "overlay not found" ); // если не находит оверлей нвидии то выводит это сообщение

		auto apply_window_styles = [ ] ( ) -> utils::e_status { // авто переменная эплай виндов стайл, ссылается на утилки и е статус, который возврашает либо ноль при успехе и другое при ошибке
			TRACE_FN; // логгирование

			// style
			SetWindowLongW( // функция которая изменяет атрибут окна, принимает в качестве аргумента хендл окна, потом идёт параметр инт который определяет какой атриюут нужно изменить и третий аругмент это значение на замену
				vars::m_window_hwnd, // хендл окна, которую нужно изменить, это именно тот самый который крепится к нвидиа оверелй, то есть по факту это оверлей нвидии
				-20, // в данном случае меняется -20 параметр, этот параметр это GWL_EXSTYLE который задает новый расширенный стиль окна
				static_cast< LONG_PTR >( // кастуется длинный тип со знаком для точности указателя приводится все к длинному обьекту 
					static_cast< int >( GetWindowLongW( vars::m_window_hwnd, -20 ) ) | 0x20 // внутри кастования находится ещё один каст на интегер, который берет функцию GetWindowLongW эта функция судя по справке извлекает сведения об указанном окне. Окно берется оверлея и инт который передается -20 это тот же самое извлечение стиля расширенного окна, все это возвращает лонг значение иначе нулл
				)
			);

			// transparency
			MARGINS margin = { -1, -1, -1, -1 }; // задается переменная с типом маргинс, маргинс это структура в которой находятся параметры ширины правой и левой границы и высоты верхней и нижней границы задается минус 1 везде но что это означает хз, наверне на весь экран и минус один пиксель
			DwmExtendFrameIntoClientArea( // эта функция расширяет рамку окна в клиентую область, в качестве аргумента принимает хендл окна + сами маргинсы указанные
				vars::m_window_hwnd, // в данном случае хендл оверлея нвидии берется
				&margin // а маргины берется которая была указана выше где все значения по минус единице
			);
			L_ASSERT( SetLayeredWindowAttributes( // ассерт функции, которая задает ключ цвета прозрачности многослойного окна аргумент принимает хендл окна, потом идёт ключ цвета прозрачности, все пиксели которые будут коорашены этим цветом станут прохрачным, третий аругмент альфа канал где 0 прозрачный 255 непрозрачный байтовое значение, степерь прозрачности, дальше чевтерный определение действие которое зависит от указанного значения
				vars::m_window_hwnd, // первый аргумент, просто хендл оверлея нвидии
				0x000000, // этот цвет будет и заменяется на прозрачность, в данном случае судя по нулям это черный цвет
				0xFF, // тут непонятно, то фф означает 255 в нех коде, как раз таки непрозрачно, тут непонятно как логика, наверное создается непрозрачное окно черного цвтеа, а ключ цвета черный меняет черный на прозрачный
				0x02 // флаг 02 означает использовать альфа канал который выше 255 для опредлеения уровеня непрозрачносьти окна 
			), "SetLayeredWindowAttributes() returned false" ); // ага я понял, если функция возращается НЕ успешно, то есть нулл, то пишется вот это вот сообщение

			// top most
			L_ASSERT( SetWindowPos( // ассерт функции которая изменяет положоение и порядок окна, принимает в качестве аргументов хендл окна. порядок окна перед окном другим, потом координаты и ширины изменение окна и в конце флаги специальныен зависит от переданого туда значения
				vars::m_window_hwnd, // в данном случае берется хендл конечно же оверлея нвидии
				HWND_TOPMOST, // этот параметр помещает окно над всеми не самыми верхними уровнями Окно соххраняте самое верхнее положение даже если оно не активно
				0, 0, 0, 0,  // координаты нового положения окна, здесь все устанавливает на ноль. То есть тут положение левой части, верхней части, потом ширина окна и высота в пикселях
				0x0002 | 0x0001 // специальные флаги размера и положения окна. в данном случае сохраняет текущие позиции и размеры (игнорит предыдущие нули тип).
			), "SetWindowPos() returned false" ); // если функция НУЛЛ то есть неуспешно, то выводится это сообщение

			return utils::e_status::status_ok; // возвращает из нейспейса утилкой и е статуса статус ОК тип
		};

		L_ASSERT( apply_window_styles( ), "cannot apply styles" ); // ассерт это эпплай виндов стайл переменной, и если она в итоге возращает нулл, то есть безуспешно то выводмтся этос ообщение
		L_ASSERT( ShowWindow( vars::m_window_hwnd, SW_SHOW ), "ShowWindow() returned false" ); // ассерт фукции шов винды, которая выводит именно наш оверлей нвидии, если его не выводит что говорит там св шоу, то выовдит слудующее сообщние
		// то есть по факту мы получаем то, что тут логируютяс все действия и в случае какой либо ошибки понять, где именно произошла ошибка
		L_ASSERT( GetClientRect( vars::m_window_hwnd, &vars::m_window_rect ), "GetClientRect() returned false" ); // тут тоже самое, ассерт функции гет лкиент рект который извлекает координаты клиент области окна, тут передается хендл овереля нвидии и также параметры собственно окна, то есть координаты
		vars::m_window_size = D2D1::SizeU( vars::m_window_rect.right - vars::m_window_rect.left, vars::m_window_rect.bottom - vars::m_window_rect.top ); // сайз Ю создает структуру с заданными параметрами ширины и высоты, тут ширина минус право и лево от размера окна, а высота это дно окна минус его топ и все это сохранется в переменной m_window_size

		return utils::e_status::status_ok; // возвращает статус ок
	}
}
